:py:mod:`harlow.sampling.lola_voronoi_modified`
===============================================

.. py:module:: harlow.sampling.lola_voronoi_modified


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   harlow.sampling.lola_voronoi_modified.LolaVoronoi



Functions
~~~~~~~~~

.. autoapisummary::

   harlow.sampling.lola_voronoi_modified.best_new_points
   harlow.sampling.lola_voronoi_modified.best_new_points_with_neighbors
   harlow.sampling.lola_voronoi_modified.best_neighborhoods
   harlow.sampling.lola_voronoi_modified.best_neighborhoods_numba
   harlow.sampling.lola_voronoi_modified.get_point_labels
   harlow.sampling.lola_voronoi_modified.lola_voronoi_score
   harlow.sampling.lola_voronoi_modified.neighborhood_score
   harlow.sampling.lola_voronoi_modified.lola_score
   harlow.sampling.lola_voronoi_modified.nonlinearity_measure
   harlow.sampling.lola_voronoi_modified.voronoi_volume_estimate
   harlow.sampling.lola_voronoi_modified.gradient_estimate



Attributes
~~~~~~~~~~

.. autoapisummary::

   harlow.sampling.lola_voronoi_modified.nopython
   harlow.sampling.lola_voronoi_modified.fastmath


.. py:data:: nopython
   :annotation: = True

   

.. py:data:: fastmath
   :annotation: = True

   

.. py:class:: LolaVoronoi(target_function: Callable[[numpy.ndarray], numpy.ndarray], surrogate_model: harlow.surrogating.surrogate_model.Surrogate, domain_lower_bound: numpy.ndarray, domain_upper_bound: numpy.ndarray, fit_points_x: numpy.ndarray = None, fit_points_y: numpy.ndarray = None, test_points_x: numpy.ndarray = None, test_points_y: numpy.ndarray = None, evaluation_metric: Callable = None, run_name: str = '', save_dir: str = '')

   Bases: :py:obj:`harlow.sampling.sampling_baseclass.Sampler`

   Lola-Vornoi adaptive design strategy for global surrogate modelling.

   The algorithm is proposed and described in this paper:
   [1] Crombecq, Karel, et al. (2011) A novel hybrid sequential design strategy for global
   surrogate modeling of computer experiments. SIAM Journal on Scientific Computing 33.4
   (2011): 1948-1974.

   The implementation is influenced by:
   * gitlab.com/energyincities/besos/-/blob/master/besos/
   * https://github.com/FuhgJan/StateOfTheArtAdaptiveSampling/blob/master/src/adaptive_techniques/LOLA_function.m  # noqa E501


   .. py:method:: sample(n_initial_point: int = None, n_iter: int = 20, n_new_point_per_iteration: int = 1, stopping_criterium: float = None, ignore_far_neighborhoods: Optional[bool] = True, ignore_old_neighborhoods: Optional[bool] = True)

      TODO: allow for providing starting points


   .. py:method:: save_model()


   .. py:method:: result_as_dict()



.. py:function:: best_new_points(points_x: numpy.ndarray, points_y: numpy.ndarray, domain_lower_bound: numpy.ndarray, domain_upper_bound: numpy.ndarray, n_point_last_iter: int, n_new_point: int = 1, ignore_far_neighborhoods: Optional[bool] = True, ignore_old_neighborhoods: Optional[bool] = True)


.. py:function:: best_new_points_with_neighbors(reference_points_x: numpy.ndarray, reference_points_y: numpy.ndarray, all_neighbor_points_x: numpy.ndarray, all_neighbor_points_y: numpy.ndarray, domain_lower_bound: numpy.ndarray, domain_upper_bound: numpy.ndarray, n_next_point: int)

   Find the new/next reference point(s) where the target function will be evaluated.

   TODO: reuse the random point used here for other calls of this function (
       `best_next_points`)


.. py:function:: best_neighborhoods(points_x: numpy.ndarray, n_point_last_iter: numpy.ndarray, n_new_point_per_iter, ignore_far_neighborhoods: Optional[bool] = True, ignore_old_neighborhoods: Optional[bool] = True)

   Find the best neighborhood for each row of `points_x`. This function is expected
   to be used with the initial sample of `points_x`, when no best neighborhoods yet
   available from preceding iteration steps. This function exists to separate numba
   compatible code from non-compatible one.


.. py:function:: best_neighborhoods_numba(points_x: numpy.ndarray, neighbor_point_combinations: numpy.ndarray, n_point_last_iter: int, n_new_point_per_iter, ignore_far_neighborhoods: Optional[bool] = True, ignore_old_neighborhoods: Optional[bool] = True) -> Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]

   Find the best neighborhood for each row of `points_x`. This function is expected
   to be used with the initial sample of `points_x`, when no best neighborhoods yet
   available from preceding iteration steps.

   :param points_x: n_point x n_dim.
   :param neighbor_point_combinations:
   :param n_point_last_iter:
   :param ignore_far_neighborhoods:
   :param ignore_old_neighborhoods:

   Returns:

   .. todo::

      * It may be possible to refactor this part. Instead of creating the
      array of all valid combinations for N points, create the array for
      N-1 points. At each iteration of this loop we ignore the reference
      point, meaning that every time we can use the same combination of
      N-1 points, but with different indices. The indices in the array of
      combinations can be considered as 'labels'. Instead of excluding all
      combinations with the reference point at each iteration (which is costly),
      we can simply change the mapping between 'labels' and points.
      * The neighborhood score for a given reference point can not decrease
       between iterations. This allows us to only store a single best score
       for each point, instead of a n_neighborhood x n_point array of scores.


.. py:function:: get_point_labels(points, label_array, point_array)

   Get the labels of a set of points given two arrays that
   define a mapping between labels and points.

   WARNING: This function will not work correctly if there are
   elements in `points` that do not exist in `point_array`.


.. py:function:: lola_voronoi_score(nonlinearity_measures: numpy.ndarray, relative_volumes: numpy.ndarray) -> numpy.ndarray

   Eq.(5.1) of [1].


.. py:function:: neighborhood_score(neighbor_points_x: numpy.ndarray, reference_point_x: numpy.ndarray) -> Tuple[float, float]

   :param neighbor_points_x: n_point x n_dim.
   :param reference_point_x: 1 x n_dim

   :returns: Neighborhood score.


.. py:function:: lola_score(all_neighbor_points_x: numpy.ndarray, all_neighbor_points_y: numpy.ndarray, reference_points_x: numpy.ndarray, reference_points_y: numpy.ndarray) -> numpy.ndarray

   Non-linearity measure for each point and its neighbor. Measures how much a
   neighborhood deviates from a hyperplane.


.. py:function:: nonlinearity_measure(reference_point_x: numpy.ndarray, reference_point_y: float, reference_point_gradient: numpy.ndarray, neighbor_points_x: numpy.ndarray, neighbor_points_y: numpy.ndarray) -> float


.. py:function:: voronoi_volume_estimate(points: numpy.ndarray, domain_lower_bound: numpy.ndarray, domain_upper_bound: numpy.ndarray, n_simulation: int = None, random_points: numpy.ndarray = None) -> Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]

   Estimate the relative volume of the Voronoi tessellation of `points` bounded by
   `domain_lower_bound` and `domain_upper_bound`.

   The algorithm is described in section 3 of [1].

   :param points: n_point x n_dim.
   :param domain_lower_bound: n_dim.
   :param domain_upper_bound: n_dim
   :param n_simulation: Number of random points used to estimate the relative volumes. If
                        `random_points` is provided then this argument is ignored.
   :param random_points:

   :returns: Relative volumes in the same order as `points`.


.. py:function:: gradient_estimate(reference_point_x: numpy.ndarray, reference_point_y: float, neighbor_points_x: numpy.ndarray, neighbor_points_y: numpy.ndarray) -> numpy.ndarray

   Estimate the gradient at `reference_point` by fitting a hyperplane to
   `neighbor_points` in a least-square sense. A hyperplane that goes exactly
   through the `reference_point`.

   We think that the there is a mistake in Eq.(4.8) of [1], the right hand side
   should be `f(p_neighbor) - f(p_reference)`, or on the left hand side the
   `-p_reference` should be dropped if the formulation is in line with this:
   "Without loss of generality, we assume that pr lies in the origin."
   section 4.2.1 of [1].

   :param reference_point_x: 1 x n_dim.
   :param reference_point_y:
   :param neighbor_points_x: n_neighbor x n_dim.
   :param neighbor_points_y: n_neighbor x 1.

   :returns: Gradient estimate, 1 x n_dim.


